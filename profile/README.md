# Frel UI

Frel UI aims to be a language and platform-agnostic UI library.

Repositories:

* [frel-spec](https://github.com/frel-ui/frel-spec) - specification and design documents
* [frel-rs](https://github.com/frel-ui/frel-rs) - Rust implementation
* [frel-kt](https://github.com/frel-ui/frel-kt) - Kotlin implementation

## Project Status: Early Design Phase

Frel is currently in the **planning and early design** stage.

Expect:

- Rapidly changing concepts and structures
- Incomplete or exploratory code
- Discussions and design documents instead of working examples

If you’re interested in the long-term vision or want to follow the design process,
check out the [frel-spec](https://github.com/frel-ui/frel-spec) repository.

If you’re looking for a production-ready UI library — check back later!

## Current Focus

- Designing the architecture
- Writing parts which have somewhat finished designs

## Relationship to Adaptive (Kotlin)

Frel builds on ideas and experience from [**Adaptive**](https://adaptive.fun) —  
a much broader library written in Kotlin ([github.com/spxbhuhb/adaptive](https://github.com/spxbhuhb/adaptive)).

Adaptive covers a wide range of application-level functionality; Frel focuses specifically on
**the UI-related aspects**.

Planned migrations from Adaptive include:

- **Fragment DSL**
- **Layout algorithms**
- **Style system** and resource management concepts
- **Platform connectors** for rendering and input abstraction
- **UI fragment library**

Frel is not a direct port. I plan to use some parts of Adaptive, but the core reactivity
concept is redesigned from scratch. Adaptive uses bit masks and closures inspired by Svelte.
It works, but it makes separation of concerns difficult.

## Contributing

Early feedback on design direction, architecture, and API ideas is welcome through
GitHub discussions or issues. Once the design stabilizes, contribution guidelines will be added.

## AI Assist Policy

Let's assume that we are smart people, and we do think before we act. Also, let's
not assume that it will be viable to code without AI assistants in the future.

With those two assumptions in mind, feel free to generate whatever you want (I do),
but please, pretty please, **think** when you do so.

I use AI extensively to help me with the design process. I do read what they generate
and adjust it as I see fit. That said, my experience is that something always slips
through the cracks, sorry about that.

Eventually I will clean up the design documents and they will change less frequently.

For utils, I will freely use any AI assistants. These are small helper programs;
it’s acceptable if they’re not perfect (within reason).

Unit tests will almost always be generated by AI.

Library code will need very strict review. I guess this will evolve over time, for
now I try to **think** before adding anything written by AI.

## License

This project is licensed under either of

- **Apache License, Version 2.0**, ([LICENSE-APACHE](LICENSE-APACHE) or <https://www.apache.org/licenses/LICENSE-2.0>)
- **MIT license**, ([LICENSE-MIT](LICENSE-MIT) or <https://opensource.org/licenses/MIT>)

at your option.

Unless you explicitly state otherwise, any contribution intentionally submitted  
for inclusion in this project by you, as defined in the Apache-2.0 license,  
shall be dual licensed as above, without any additional terms or conditions.